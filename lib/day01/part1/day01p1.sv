/**
 * Generated by ROHD - www.github.com/intel/rohd
 * Generation time: 2025-11-30 21:30:23.440 -08:00
 * ROHD Version: 0.6.6
 */

module Sum_2_W64 (
    input logic [63:0] amount_0,
    input logic enable_0,
    input logic [63:0] amount_1,
    input logic enable_1,
    input logic [63:0] initialValue,
    input logic [63:0] minValue,
    input logic [63:0] maxValue,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [63:0] sum
);
  logic [66:0] _in0__swizzled_add_zeroPoint;
  logic [66:0] _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
  logic [66:0] _in3__internalValue_add__swizzled;
  logic _internalValue_add__swizzled_carry;
  logic _internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry;
  logic _maxValueExt_add_zeroPoint_carry;
  logic _maxValueExt_subtract_minValueExt_add_const_1_carry;
  logic _minValueExt_add_zeroPoint_carry;
  logic _swizzled_add_zeroPoint_carry;
  logic [66:0] internalValue;
  logic [66:0] internalValueOverZeroPoint;
  logic [66:0] internalValue_0;
  logic [66:0] internalValue_1;
  logic [66:0] internalValue_2;
  logic [66:0] internalValue_3;
  logic [66:0] internalValue_4;
  logic [66:0] internalValue_5;
  logic [66:0] internalValue_phi;
  logic [66:0] lowerSaturation;
  logic [66:0] maxValueExt;
  logic [66:0] minValueExt;
  logic [66:0] preAdjustmentValue;
  logic [66:0] range;
  logic [66:0] upperSaturation;
  logic [66:0] zeroPoint;
  assign zeroPoint = 67'h1fffffffffffffffe;
  //  combinational_ssa
  always_comb begin
    internalValue_4 = _in0__swizzled_add_zeroPoint;
    if (enable_0) begin
      internalValue_0 = _in3__internalValue_add__swizzled;
      internalValue_5 = internalValue_0;
    end else begin
      internalValue_5 = internalValue_4;
      internalValue_0 = 67'h0;
    end

    if (enable_1) begin
      internalValue_1   = (internalValue_5 - ({3'h0,  /* 66:64 */
 amount_1  /* 63: 0 */
}));
      internalValue_phi = internalValue_1;
    end else begin
      internalValue_phi = internalValue_5;
      internalValue_1   = 67'h0;
    end

    overflowed = (internalValue_phi > upperSaturation);
    underflowed = (internalValue_phi < lowerSaturation);
    preAdjustmentValue = internalValue_phi;
    if (overflowed) begin
      internalValue_2 = _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
      internalValue = internalValue_2;
      internalValue_3 = 67'h0;
    end else if (underflowed) begin
      internalValue_3 = (upperSaturation - (((lowerSaturation - internalValue_phi) - 67'h1) % range));
      internalValue = internalValue_3;
      internalValue_2 = 67'h0;
    end else begin
      internalValue   = internalValue_phi;
      internalValue_2 = 67'h0;
      internalValue_3 = 67'h0;
    end

  end

  assign {_swizzled_add_zeroPoint_carry, _in0__swizzled_add_zeroPoint} = ({3'h0,  /* 66:64 */
      initialValue  /* 63: 0 */
      }) + zeroPoint;
  assign {_maxValueExt_add_zeroPoint_carry, upperSaturation} = maxValueExt + zeroPoint;
  assign {_internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry, _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation} = (((internalValue_phi - upperSaturation) - 67'h1) % range) + lowerSaturation;
  assign {_maxValueExt_subtract_minValueExt_add_const_1_carry, range} = (maxValueExt - minValueExt) + 67'h1;
  assign maxValueExt = {
    3'h0,  /* 66:64 */
    maxValue  /* 63: 0 */
  };  // swizzle_0
  assign {_minValueExt_add_zeroPoint_carry, lowerSaturation} = minValueExt + zeroPoint;
  assign minValueExt = {
    3'h0,  /* 66:64 */
    minValue  /* 63: 0 */
  };  // swizzle_1
  assign equalsMin = internalValue == lowerSaturation;  // equals
  assign internalValueOverZeroPoint = internalValue - zeroPoint;  // subtract_5
  assign sum = internalValueOverZeroPoint[63:0];  // bussubset
  assign equalsMax = internalValue == upperSaturation;  // equals_0
  assign {_internalValue_add__swizzled_carry, _in3__internalValue_add__swizzled} = internalValue_4 + ({
3'h0, /* 66:64 */
      amount_0  /* 63: 0 */
      });
endmodule : Sum_2_W64

////////////////////

module Sum_1_W13 (
    input logic enable_0,
    input logic [12:0] initialValue,
    input logic [12:0] minValue,
    input logic [12:0] maxValue,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [12:0] sum
);
  logic [14:0] _in0__swizzled_add_zeroPoint;
  logic [14:0] _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
  logic [14:0] _in3__internalValue_add__swizzled;
  logic _internalValue_add__swizzled_carry;
  logic _internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry;
  logic _maxValueExt_add_zeroPoint_carry;
  logic _maxValueExt_subtract_minValueExt_add_const_1_carry;
  logic _minValueExt_add_zeroPoint_carry;
  logic _swizzled_add_zeroPoint_carry;
  logic [14:0] internalValue;
  logic [14:0] internalValueOverZeroPoint;
  logic [14:0] internalValue_0;
  logic [14:0] internalValue_1;
  logic [14:0] internalValue_2;
  logic [14:0] internalValue_3;
  logic [14:0] internalValue_phi;
  logic [14:0] lowerSaturation;
  logic [14:0] maxValueExt;
  logic [14:0] minValueExt;
  logic [14:0] preAdjustmentValue;
  logic [14:0] range;
  logic [14:0] upperSaturation;
  logic [14:0] zeroPoint;
  assign zeroPoint = 15'h1fff;
  //  combinational_ssa
  always_comb begin
    internalValue_3 = _in0__swizzled_add_zeroPoint;
    if (enable_0) begin
      internalValue_0   = _in3__internalValue_add__swizzled;
      internalValue_phi = internalValue_0;
    end else begin
      internalValue_phi = internalValue_3;
      internalValue_0   = 15'h0;
    end

    overflowed = (internalValue_phi > upperSaturation);
    underflowed = (internalValue_phi < lowerSaturation);
    preAdjustmentValue = internalValue_phi;
    if (overflowed) begin
      internalValue_1 = _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
      internalValue = internalValue_1;
      internalValue_2 = 15'h0;
    end else if (underflowed) begin
      internalValue_2 = (upperSaturation - (((lowerSaturation - internalValue_phi) - 15'h1) % range));
      internalValue = internalValue_2;
      internalValue_1 = 15'h0;
    end else begin
      internalValue   = internalValue_phi;
      internalValue_1 = 15'h0;
      internalValue_2 = 15'h0;
    end

  end

  assign {_swizzled_add_zeroPoint_carry, _in0__swizzled_add_zeroPoint} = ({2'h0,  /* 14:13 */
      initialValue  /* 12: 0 */
      }) + zeroPoint;
  assign {_maxValueExt_add_zeroPoint_carry, upperSaturation} = maxValueExt + zeroPoint;
  assign {_internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry, _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation} = (((internalValue_phi - upperSaturation) - 15'h1) % range) + lowerSaturation;
  assign {_maxValueExt_subtract_minValueExt_add_const_1_carry, range} = (maxValueExt - minValueExt) + 15'h1;
  assign maxValueExt = {
    2'h0,  /* 14:13 */
    maxValue  /* 12: 0 */
  };  // swizzle_0
  assign {_minValueExt_add_zeroPoint_carry, lowerSaturation} = minValueExt + zeroPoint;
  assign minValueExt = {
    2'h0,  /* 14:13 */
    minValue  /* 12: 0 */
  };  // swizzle_1
  assign equalsMin = internalValue == lowerSaturation;  // equals
  assign internalValueOverZeroPoint = internalValue - zeroPoint;  // subtract_5
  assign sum = internalValueOverZeroPoint[12:0];  // bussubset
  assign equalsMax = internalValue == upperSaturation;  // equals_0
  assign {_internalValue_add__swizzled_carry, _in3__internalValue_add__swizzled} = internalValue_3 + ({
14'h0, /* 14:1 */
      1'h1  /*    0 */
      });
endmodule : Sum_1_W13

////////////////////

module Counter_L2_ (
    input logic [63:0] amount_0,
    input logic enable_0,
    input logic [63:0] amount_1,
    input logic enable_1,
    input logic clk,
    input logic reset,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [63:0] count
);
  logic equalsMax_0;
  logic equalsMin_0;
  logic [63:0] initialValue;
  logic [63:0] maxValue;
  logic [63:0] minValue;
  logic overflowed_0;
  logic [63:0] sum_0;
  logic underflowed_0;
  assign initialValue = 64'h32;
  assign minValue = 64'h0;
  assign maxValue = 64'h63;
  always_ff @(posedge clk)
    if (reset) overflowed <= 1'h0;
    else overflowed <= overflowed_0;  // flipflop
  Sum_2_W64 sum (
      .amount_0(amount_0),
      .enable_0(enable_0),
      .amount_1(amount_1),
      .enable_1(enable_1),
      .initialValue((count)),
      .minValue((minValue)),
      .maxValue((maxValue)),
      .overflowed(overflowed_0),
      .underflowed(underflowed_0),
      .equalsMax(equalsMax_0),
      .equalsMin(equalsMin_0),
      .sum(sum_0)
  );
  always_ff @(posedge clk)
    if (reset) count <= initialValue;
    else count <= sum_0;  // flipflop_0
  assign equalsMin = count == minValue;  // equals
  assign equalsMax = count == maxValue;  // equals_0
  always_ff @(posedge clk)
    if (reset) underflowed <= 1'h0;
    else underflowed <= underflowed_0;  // flipflop_1
endmodule : Counter_L2_

////////////////////

module Counter_L1_ (
    input logic enable_0,
    input logic clk,
    input logic reset,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [12:0] count
);
  logic equalsMax_0;
  logic equalsMin_0;
  logic [12:0] initialValue;
  logic [12:0] maxValue;
  logic [12:0] minValue;
  logic overflowed_0;
  logic [12:0] sum_0;
  logic underflowed_0;
  assign initialValue = 13'h0;
  assign minValue = 13'h0;
  assign maxValue = 13'h1052;
  always_ff @(posedge clk)
    if (reset) overflowed <= 1'h0;
    else overflowed <= overflowed_0;  // flipflop
  Sum_1_W13 sum (
      .enable_0(enable_0),
      .initialValue((count)),
      .minValue((minValue)),
      .maxValue((maxValue)),
      .overflowed(overflowed_0),
      .underflowed(underflowed_0),
      .equalsMax(equalsMax_0),
      .equalsMin(equalsMin_0),
      .sum(sum_0)
  );
  always_ff @(posedge clk)
    if (reset) count <= initialValue;
    else count <= sum_0;  // flipflop_0
  assign equalsMin = count == minValue;  // equals
  assign equalsMax = count == maxValue;  // equals_0
  always_ff @(posedge clk)
    if (reset) underflowed <= 1'h0;
    else underflowed <= underflowed_0;  // flipflop_1
endmodule : Counter_L1_

////////////////////

module Day01 (
    input logic clk,
    input logic reset,
    input logic [63:0] value,
    input logic enable,
    input logic direction,
    output logic [12:0] zeroCount
);
  logic [63:0] count;
  logic equalsMax;
  logic equalsMax_0;
  logic equalsMin;
  logic equalsMin_0;
  logic overflowed;
  logic overflowed_0;
  logic underflowed;
  logic underflowed_0;
  Counter_L1_ zeroCounter (
      .enable_0((equalsMin_0 & enable)),
      .clk(clk),
      .reset(reset),
      .overflowed(overflowed),
      .underflowed(underflowed),
      .equalsMax(equalsMax),
      .equalsMin(equalsMin),
      .count(zeroCount)
  );
  Counter_L2_ dialPositionCounter (
      .amount_0(value),
      .enable_0((enable & (direction == 1'h0))),
      .amount_1(value),
      .enable_1((enable & (direction == 1'h1))),
      .clk(clk),
      .reset(reset),
      .overflowed(overflowed_0),
      .underflowed(underflowed_0),
      .equalsMax(equalsMax_0),
      .equalsMin(equalsMin_0),
      .count(count)
  );
endmodule : Day01
