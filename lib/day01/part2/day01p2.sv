/**
 * Generated by ROHD - www.github.com/intel/rohd
 * Generation time: 2025-11-30 23:34:43.781 -08:00
 * ROHD Version: 0.6.6
 */

module Sum_1_W16 (
    input logic enable_0,
    input logic [15:0] initialValue,
    input logic [15:0] minValue,
    input logic [15:0] maxValue,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [15:0] sum
);
  logic [17:0] _in0__swizzled_add_zeroPoint;
  logic [17:0] _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
  logic [17:0] _in3__internalValue_add__swizzled;
  logic _internalValue_add__swizzled_carry;
  logic _internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry;
  logic _maxValueExt_add_zeroPoint_carry;
  logic _maxValueExt_subtract_minValueExt_add_const_1_carry;
  logic _minValueExt_add_zeroPoint_carry;
  logic _swizzled_add_zeroPoint_carry;
  logic [17:0] internalValue;
  logic [17:0] internalValueOverZeroPoint;
  logic [17:0] internalValue_0;
  logic [17:0] internalValue_1;
  logic [17:0] internalValue_2;
  logic [17:0] internalValue_3;
  logic [17:0] internalValue_phi;
  logic [17:0] lowerSaturation;
  logic [17:0] maxValueExt;
  logic [17:0] minValueExt;
  logic [17:0] preAdjustmentValue;
  logic [17:0] range;
  logic [17:0] upperSaturation;
  logic [17:0] zeroPoint;
  assign zeroPoint = 18'hffff;
  //  combinational_ssa
  always_comb begin
    internalValue_3 = _in0__swizzled_add_zeroPoint;
    if (enable_0) begin
      internalValue_0   = _in3__internalValue_add__swizzled;
      internalValue_phi = internalValue_0;
    end else begin
      internalValue_phi = internalValue_3;
      internalValue_0   = 18'h0;
    end

    overflowed = (internalValue_phi > upperSaturation);
    underflowed = (internalValue_phi < lowerSaturation);
    preAdjustmentValue = internalValue_phi;
    if (overflowed) begin
      internalValue_1 = _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
      internalValue = internalValue_1;
      internalValue_2 = 18'h0;
    end else if (underflowed) begin
      internalValue_2 = (upperSaturation - (((lowerSaturation - internalValue_phi) - 18'h1) % range));
      internalValue = internalValue_2;
      internalValue_1 = 18'h0;
    end else begin
      internalValue   = internalValue_phi;
      internalValue_1 = 18'h0;
      internalValue_2 = 18'h0;
    end

  end

  assign {_swizzled_add_zeroPoint_carry, _in0__swizzled_add_zeroPoint} = ({2'h0,  /* 17:16 */
      initialValue  /* 15: 0 */
      }) + zeroPoint;
  assign {_maxValueExt_add_zeroPoint_carry, upperSaturation} = maxValueExt + zeroPoint;
  assign {_internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry, _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation} = (((internalValue_phi - upperSaturation) - 18'h1) % range) + lowerSaturation;
  assign {_maxValueExt_subtract_minValueExt_add_const_1_carry, range} = (maxValueExt - minValueExt) + 18'h1;
  assign maxValueExt = {
    2'h0,  /* 17:16 */
    maxValue  /* 15: 0 */
  };  // swizzle_0
  assign {_minValueExt_add_zeroPoint_carry, lowerSaturation} = minValueExt + zeroPoint;
  assign minValueExt = {
    2'h0,  /* 17:16 */
    minValue  /* 15: 0 */
  };  // swizzle_1
  assign equalsMin = internalValue == lowerSaturation;  // equals
  assign internalValueOverZeroPoint = internalValue - zeroPoint;  // subtract_5
  assign sum = internalValueOverZeroPoint[15:0];  // bussubset
  assign equalsMax = internalValue == upperSaturation;  // equals_0
  assign {_internalValue_add__swizzled_carry, _in3__internalValue_add__swizzled} = internalValue_3 + ({
17'h0, /* 17:1 */
      1'h1  /*    0 */
      });
endmodule : Sum_1_W16

////////////////////

module Sum_2_W32 (
    input logic [31:0] amount_0,
    input logic enable_0,
    input logic [31:0] amount_1,
    input logic enable_1,
    input logic [31:0] initialValue,
    input logic [31:0] minValue,
    input logic [31:0] maxValue,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [31:0] sum
);
  logic [34:0] _in0__swizzled_add_zeroPoint;
  logic [34:0] _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
  logic [34:0] _in3__internalValue_add__swizzled;
  logic _internalValue_add__swizzled_carry;
  logic _internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry;
  logic _maxValueExt_add_zeroPoint_carry;
  logic _maxValueExt_subtract_minValueExt_add_const_1_carry;
  logic _minValueExt_add_zeroPoint_carry;
  logic _swizzled_add_zeroPoint_carry;
  logic [34:0] internalValue;
  logic [34:0] internalValueOverZeroPoint;
  logic [34:0] internalValue_0;
  logic [34:0] internalValue_1;
  logic [34:0] internalValue_2;
  logic [34:0] internalValue_3;
  logic [34:0] internalValue_4;
  logic [34:0] internalValue_5;
  logic [34:0] internalValue_phi;
  logic [34:0] lowerSaturation;
  logic [34:0] maxValueExt;
  logic [34:0] minValueExt;
  logic [34:0] preAdjustmentValue;
  logic [34:0] range;
  logic [34:0] upperSaturation;
  logic [34:0] zeroPoint;
  assign zeroPoint = 35'h1fffffffe;
  //  combinational_ssa
  always_comb begin
    internalValue_4 = _in0__swizzled_add_zeroPoint;
    if (enable_0) begin
      internalValue_0 = _in3__internalValue_add__swizzled;
      internalValue_5 = internalValue_0;
    end else begin
      internalValue_5 = internalValue_4;
      internalValue_0 = 35'h0;
    end

    if (enable_1) begin
      internalValue_1   = (internalValue_5 - ({3'h0,  /* 34:32 */
 amount_1  /* 31: 0 */
}));
      internalValue_phi = internalValue_1;
    end else begin
      internalValue_phi = internalValue_5;
      internalValue_1   = 35'h0;
    end

    overflowed = (internalValue_phi > upperSaturation);
    underflowed = (internalValue_phi < lowerSaturation);
    preAdjustmentValue = internalValue_phi;
    if (overflowed) begin
      internalValue_2 = _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
      internalValue = internalValue_2;
      internalValue_3 = 35'h0;
    end else if (underflowed) begin
      internalValue_3 = (upperSaturation - (((lowerSaturation - internalValue_phi) - 35'h1) % range));
      internalValue = internalValue_3;
      internalValue_2 = 35'h0;
    end else begin
      internalValue   = internalValue_phi;
      internalValue_2 = 35'h0;
      internalValue_3 = 35'h0;
    end

  end

  assign {_swizzled_add_zeroPoint_carry, _in0__swizzled_add_zeroPoint} = ({3'h0,  /* 34:32 */
      initialValue  /* 31: 0 */
      }) + zeroPoint;
  assign {_maxValueExt_add_zeroPoint_carry, upperSaturation} = maxValueExt + zeroPoint;
  assign {_internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry, _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation} = (((internalValue_phi - upperSaturation) - 35'h1) % range) + lowerSaturation;
  assign {_maxValueExt_subtract_minValueExt_add_const_1_carry, range} = (maxValueExt - minValueExt) + 35'h1;
  assign maxValueExt = {
    3'h0,  /* 34:32 */
    maxValue  /* 31: 0 */
  };  // swizzle_0
  assign {_minValueExt_add_zeroPoint_carry, lowerSaturation} = minValueExt + zeroPoint;
  assign minValueExt = {
    3'h0,  /* 34:32 */
    minValue  /* 31: 0 */
  };  // swizzle_1
  assign equalsMin = internalValue == lowerSaturation;  // equals
  assign internalValueOverZeroPoint = internalValue - zeroPoint;  // subtract_5
  assign sum = internalValueOverZeroPoint[31:0];  // bussubset
  assign equalsMax = internalValue == upperSaturation;  // equals_0
  assign {_internalValue_add__swizzled_carry, _in3__internalValue_add__swizzled} = internalValue_4 + ({
3'h0, /* 34:32 */
      amount_0  /* 31: 0 */
      });
endmodule : Sum_2_W32

////////////////////

module Counter_L1_ (
    input logic enable_0,
    input logic clk,
    input logic reset,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [15:0] count
);
  logic equalsMax_0;
  logic equalsMin_0;
  logic [15:0] initialValue;
  logic [15:0] maxValue;
  logic [15:0] minValue;
  logic overflowed_0;
  logic [15:0] sum_0;
  logic underflowed_0;
  assign initialValue = 16'h0;
  assign minValue = 16'h0;
  assign maxValue = 16'hb37b;
  always_ff @(posedge clk)
    if (reset) overflowed <= 1'h0;
    else overflowed <= overflowed_0;  // flipflop
  Sum_1_W16 sum (
      .enable_0(enable_0),
      .initialValue((count)),
      .minValue((minValue)),
      .maxValue((maxValue)),
      .overflowed(overflowed_0),
      .underflowed(underflowed_0),
      .equalsMax(equalsMax_0),
      .equalsMin(equalsMin_0),
      .sum(sum_0)
  );
  always_ff @(posedge clk)
    if (reset) count <= initialValue;
    else count <= sum_0;  // flipflop_0
  assign equalsMin = count == minValue;  // equals
  assign equalsMax = count == maxValue;  // equals_0
  always_ff @(posedge clk)
    if (reset) underflowed <= 1'h0;
    else underflowed <= underflowed_0;  // flipflop_1
endmodule : Counter_L1_

////////////////////

module Counter_L2_ (
    input logic [31:0] amount_0,
    input logic enable_0,
    input logic [31:0] amount_1,
    input logic enable_1,
    input logic clk,
    input logic reset,
    output logic overflowed,
    output logic underflowed,
    output logic equalsMax,
    output logic equalsMin,
    output logic [31:0] count
);
  logic equalsMax_0;
  logic equalsMin_0;
  logic [31:0] initialValue;
  logic [31:0] maxValue;
  logic [31:0] minValue;
  logic overflowed_0;
  logic [31:0] sum_0;
  logic underflowed_0;
  assign initialValue = 32'h32;
  assign minValue = 32'h0;
  assign maxValue = 32'h63;
  always_ff @(posedge clk)
    if (reset) overflowed <= 1'h0;
    else overflowed <= overflowed_0;  // flipflop
  Sum_2_W32 sum (
      .amount_0(amount_0),
      .enable_0(enable_0),
      .amount_1(amount_1),
      .enable_1(enable_1),
      .initialValue((count)),
      .minValue((minValue)),
      .maxValue((maxValue)),
      .overflowed(overflowed_0),
      .underflowed(underflowed_0),
      .equalsMax(equalsMax_0),
      .equalsMin(equalsMin_0),
      .sum(sum_0)
  );
  always_ff @(posedge clk)
    if (reset) count <= initialValue;
    else count <= sum_0;  // flipflop_0
  assign equalsMin = count == minValue;  // equals
  assign equalsMax = count == maxValue;  // equals_0
  always_ff @(posedge clk)
    if (reset) underflowed <= 1'h0;
    else underflowed <= underflowed_0;  // flipflop_1
endmodule : Counter_L2_

////////////////////

module Day01p2 (
    input logic clk,
    input logic reset,
    input logic turnValid,
    input logic [32:0] turn,
    output logic turnReady,
    output logic [15:0] zeroCount
);
  logic ProcessingState_busy;
  logic ProcessingState_ready;
  logic [31:0] _d0__s;
  logic _in1;
  logic _in1__q;
  logic [31:0] _in3__s;
  logic _in4__s;
  logic [32:0] _original__q;
  logic [31:0] count;
  logic countEnable;
  logic currentState;
  logic [31:0] dialAmountThisCycle;
  logic enabledZero;
  logic equalsMax;
  logic equalsMax_0;
  logic equalsMin;
  logic equalsMin_0;
  logic nextState;
  logic overflowed;
  logic overflowed_0;
  logic rolledOver;
  logic turnAccepted;
  logic turnIsBig;
  logic underflowed;
  logic underflowed_0;
  logic wasZero;
  assign ProcessingState_ready = 1'h0;
  assign ProcessingState_busy = 1'h1;
  assign _in3__s = turn[31:0];  // bussubset
  assign _in4__s = turn[32];  // bussubset_0
  //  combinational
  always_comb begin
    unique case (currentState)
      ProcessingState_ready: begin
        turnReady = 1'h1;
        _d0__s = _in3__s;
        _in1 = _in4__s;
        countEnable = turnValid;
        unique case (1'h1)
          (turnAccepted & turnIsBig): begin
            nextState = 1'h1;
          end
          default: begin
            nextState = 1'h0;
          end
        endcase

      end
      ProcessingState_busy: begin
        turnReady = 1'h0;
        countEnable = 1'h1;
        _d0__s = (_original__q[31:0]);
        _in1 = (_original__q[32]);
        unique case (1'h1)
          (~turnIsBig): begin
            nextState = 1'h0;
          end
          default: begin
            nextState = 1'h1;
          end
        endcase

      end
      default: begin
        nextState = currentState;
        turnReady = 1'h0;
        _d0__s = 32'h0;
        _in1 = 1'h0;
        countEnable = 1'h0;
      end
    endcase

  end

  //  sequential
  always_ff @(posedge clk) begin
    if (reset) begin
      currentState <= 1'h0;
    end else begin
      currentState <= nextState;
    end

  end

  assign turnAccepted = turnValid & turnReady;  // and__0
  assign turnIsBig = _d0__s > 32'h64;  // greaterThan
  assign dialAmountThisCycle = turnIsBig ? 32'h64 : _d0__s;  // mux_0
  Counter_L2_ dialPositionCounter (
      .amount_0(dialAmountThisCycle),
      .enable_0((countEnable & (_in1 == 1'h0))),
      .amount_1(dialAmountThisCycle),
      .enable_1((countEnable & (_in1 == 1'h1))),
      .clk(clk),
      .reset(reset),
      .overflowed(overflowed),
      .underflowed(underflowed),
      .equalsMax(equalsMax),
      .equalsMin(equalsMin_0),
      .count(count)
  );
  assign rolledOver = (~wasZero) & (underflowed | overflowed);  // and__1
  Counter_L1_ zeroCounter (
      .enable_0((rolledOver | enabledZero)),
      .clk(clk),
      .reset(reset),
      .overflowed(overflowed_0),
      .underflowed(underflowed_0),
      .equalsMax(equalsMax_0),
      .equalsMin(equalsMin),
      .count(zeroCount)
  );
  assign enabledZero = equalsMin_0 & _in1__q;  // and__2
  always_ff @(posedge clk)
    if (reset) _in1__q <= 1'h0;
    else _in1__q <= countEnable;  // flipflop
  always_ff @(posedge clk)
    if (reset) wasZero <= 1'h0;
    else wasZero <= equalsMin_0;  // flipflop_0
  always_ff @(posedge clk)
    if (reset) _original__q <= 33'h0;
    else
      _original__q <= ({
        _in1,  /*   32 */
        (turnIsBig ? (_d0__s - 32'h64) : 32'h0)  /* 31:0 */
      });  // flipflop_1
endmodule : Day01p2
