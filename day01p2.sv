/**
 * Generated by ROHD - www.github.com/intel/rohd
 * Generation time: 2025-11-30 22:19:53.751 -08:00
 * ROHD Version: 0.6.6
 */

module Sum_1_W4 (
input logic enable_0,
input logic [3:0] initialValue,
input logic [3:0] minValue,
input logic [3:0] maxValue,
output logic overflowed,
output logic underflowed,
output logic equalsMax,
output logic equalsMin,
output logic [3:0] sum
);
logic [5:0] _in0__swizzled_add_zeroPoint;
logic [5:0] _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
logic [5:0] _in3__internalValue_add__swizzled;
logic _internalValue_add__swizzled_carry;
logic _internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry;
logic _maxValueExt_add_zeroPoint_carry;
logic _maxValueExt_subtract_minValueExt_add_const_1_carry;
logic _minValueExt_add_zeroPoint_carry;
logic _swizzled_add_zeroPoint_carry;
logic [5:0] internalValue;
logic [5:0] internalValueOverZeroPoint;
logic [5:0] internalValue_0;
logic [5:0] internalValue_1;
logic [5:0] internalValue_2;
logic [5:0] internalValue_3;
logic [5:0] internalValue_phi;
logic [5:0] lowerSaturation;
logic [5:0] maxValueExt;
logic [5:0] minValueExt;
logic [5:0] preAdjustmentValue;
logic [5:0] range;
logic [5:0] upperSaturation;
logic [5:0] zeroPoint;
assign zeroPoint = 6'hf;
//  combinational_ssa
always_comb begin
  internalValue_3 = _in0__swizzled_add_zeroPoint;
  if(enable_0) begin
      internalValue_0 = _in3__internalValue_add__swizzled;
      internalValue_phi = internalValue_0;
  end   else begin
      internalValue_phi = internalValue_3;
      internalValue_0 = 6'h0;
  end 

  overflowed = (internalValue_phi > upperSaturation);
  underflowed = (internalValue_phi < lowerSaturation);
  preAdjustmentValue = internalValue_phi;
  if(overflowed) begin
      internalValue_1 = _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
      internalValue = internalValue_1;
      internalValue_2 = 6'h0;
  end   else if(underflowed) begin
      internalValue_2 = (upperSaturation - (((lowerSaturation - internalValue_phi) - 6'h1) % range));
      internalValue = internalValue_2;
      internalValue_1 = 6'h0;
  end   else begin
      internalValue = internalValue_phi;
      internalValue_1 = 6'h0;
      internalValue_2 = 6'h0;
  end 

end

assign {_swizzled_add_zeroPoint_carry, _in0__swizzled_add_zeroPoint} = ({
2'h0, /* 5:4 */
initialValue  /* 3:0 */
}) + zeroPoint;
assign {_maxValueExt_add_zeroPoint_carry, upperSaturation} = maxValueExt + zeroPoint;
assign {_internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry, _in17__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation} = (((internalValue_phi - upperSaturation) - 6'h1) % range) + lowerSaturation;
assign {_maxValueExt_subtract_minValueExt_add_const_1_carry, range} = (maxValueExt - minValueExt) + 6'h1;
assign maxValueExt = {
2'h0, /* 5:4 */
maxValue  /* 3:0 */
};  // swizzle_0
assign {_minValueExt_add_zeroPoint_carry, lowerSaturation} = minValueExt + zeroPoint;
assign minValueExt = {
2'h0, /* 5:4 */
minValue  /* 3:0 */
};  // swizzle_1
assign equalsMin = internalValue == lowerSaturation;  // equals
assign internalValueOverZeroPoint = internalValue - zeroPoint;  // subtract_5
assign sum = internalValueOverZeroPoint[3:0];  // bussubset
assign equalsMax = internalValue == upperSaturation;  // equals_0
assign {_internalValue_add__swizzled_carry, _in3__internalValue_add__swizzled} = internalValue_3 + ({
5'h0, /* 5:1 */
1'h1  /*   0 */
});
endmodule : Sum_1_W4

////////////////////

module Sum_2_W64 (
input logic [63:0] amount_0,
input logic enable_0,
input logic [63:0] amount_1,
input logic enable_1,
input logic [63:0] initialValue,
input logic [63:0] minValue,
input logic [63:0] maxValue,
output logic overflowed,
output logic underflowed,
output logic equalsMax,
output logic equalsMin,
output logic [63:0] sum
);
logic [66:0] _in0__swizzled_add_zeroPoint;
logic [66:0] _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
logic [66:0] _in3__internalValue_add__swizzled;
logic _internalValue_add__swizzled_carry;
logic _internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry;
logic _maxValueExt_add_zeroPoint_carry;
logic _maxValueExt_subtract_minValueExt_add_const_1_carry;
logic _minValueExt_add_zeroPoint_carry;
logic _swizzled_add_zeroPoint_carry;
logic [66:0] internalValue;
logic [66:0] internalValueOverZeroPoint;
logic [66:0] internalValue_0;
logic [66:0] internalValue_1;
logic [66:0] internalValue_2;
logic [66:0] internalValue_3;
logic [66:0] internalValue_4;
logic [66:0] internalValue_5;
logic [66:0] internalValue_phi;
logic [66:0] lowerSaturation;
logic [66:0] maxValueExt;
logic [66:0] minValueExt;
logic [66:0] preAdjustmentValue;
logic [66:0] range;
logic [66:0] upperSaturation;
logic [66:0] zeroPoint;
assign zeroPoint = 67'h1fffffffffffffffe;
//  combinational_ssa
always_comb begin
  internalValue_4 = _in0__swizzled_add_zeroPoint;
  if(enable_0) begin
      internalValue_0 = _in3__internalValue_add__swizzled;
      internalValue_5 = internalValue_0;
  end   else begin
      internalValue_5 = internalValue_4;
      internalValue_0 = 67'h0;
  end 

  if(enable_1) begin
      internalValue_1 = (internalValue_5 - ({
3'h0, /* 66:64 */
amount_1  /* 63: 0 */
}));
      internalValue_phi = internalValue_1;
  end   else begin
      internalValue_phi = internalValue_5;
      internalValue_1 = 67'h0;
  end 

  overflowed = (internalValue_phi > upperSaturation);
  underflowed = (internalValue_phi < lowerSaturation);
  preAdjustmentValue = internalValue_phi;
  if(overflowed) begin
      internalValue_2 = _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation;
      internalValue = internalValue_2;
      internalValue_3 = 67'h0;
  end   else if(underflowed) begin
      internalValue_3 = (upperSaturation - (((lowerSaturation - internalValue_phi) - 67'h1) % range));
      internalValue = internalValue_3;
      internalValue_2 = 67'h0;
  end   else begin
      internalValue = internalValue_phi;
      internalValue_2 = 67'h0;
      internalValue_3 = 67'h0;
  end 

end

assign {_swizzled_add_zeroPoint_carry, _in0__swizzled_add_zeroPoint} = ({
3'h0, /* 66:64 */
initialValue  /* 63: 0 */
}) + zeroPoint;
assign {_maxValueExt_add_zeroPoint_carry, upperSaturation} = maxValueExt + zeroPoint;
assign {_internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation_carry, _in25__internalValue_subtract_upperSaturation_subtract_const_1_modulo_range_add_lowerSaturation} = (((internalValue_phi - upperSaturation) - 67'h1) % range) + lowerSaturation;
assign {_maxValueExt_subtract_minValueExt_add_const_1_carry, range} = (maxValueExt - minValueExt) + 67'h1;
assign maxValueExt = {
3'h0, /* 66:64 */
maxValue  /* 63: 0 */
};  // swizzle_0
assign {_minValueExt_add_zeroPoint_carry, lowerSaturation} = minValueExt + zeroPoint;
assign minValueExt = {
3'h0, /* 66:64 */
minValue  /* 63: 0 */
};  // swizzle_1
assign equalsMin = internalValue == lowerSaturation;  // equals
assign internalValueOverZeroPoint = internalValue - zeroPoint;  // subtract_5
assign sum = internalValueOverZeroPoint[63:0];  // bussubset
assign equalsMax = internalValue == upperSaturation;  // equals_0
assign {_internalValue_add__swizzled_carry, _in3__internalValue_add__swizzled} = internalValue_4 + ({
3'h0, /* 66:64 */
amount_0  /* 63: 0 */
});
endmodule : Sum_2_W64

////////////////////

module Counter_L1_ (
input logic enable_0,
input logic clk,
input logic reset,
output logic overflowed,
output logic underflowed,
output logic equalsMax,
output logic equalsMin,
output logic [3:0] count
);
logic equalsMax_0;
logic equalsMin_0;
logic [3:0] initialValue;
logic [3:0] maxValue;
logic [3:0] minValue;
logic overflowed_0;
logic [3:0] sum_0;
logic underflowed_0;
assign initialValue = 4'h0;
assign minValue = 4'h0;
assign maxValue = 4'ha;
always_ff @(posedge clk) if(reset) overflowed <= 1'h0; else overflowed <= overflowed_0;  // flipflop
Sum_1_W4  sum(.enable_0(enable_0),.initialValue((count)),.minValue((minValue)),.maxValue((maxValue)),.overflowed(overflowed_0),.underflowed(underflowed_0),.equalsMax(equalsMax_0),.equalsMin(equalsMin_0),.sum(sum_0));
always_ff @(posedge clk) if(reset) count <= initialValue; else count <= sum_0;  // flipflop_0
assign equalsMin = count == minValue;  // equals
assign equalsMax = count == maxValue;  // equals_0
always_ff @(posedge clk) if(reset) underflowed <= 1'h0; else underflowed <= underflowed_0;  // flipflop_1
endmodule : Counter_L1_

////////////////////

module Counter_L2_ (
input logic [63:0] amount_0,
input logic enable_0,
input logic [63:0] amount_1,
input logic enable_1,
input logic clk,
input logic reset,
output logic overflowed,
output logic underflowed,
output logic equalsMax,
output logic equalsMin,
output logic [63:0] count
);
logic equalsMax_0;
logic equalsMin_0;
logic [63:0] initialValue;
logic [63:0] maxValue;
logic [63:0] minValue;
logic overflowed_0;
logic [63:0] sum_0;
logic underflowed_0;
assign initialValue = 64'h32;
assign minValue = 64'h0;
assign maxValue = 64'h63;
always_ff @(posedge clk) if(reset) overflowed <= 1'h0; else overflowed <= overflowed_0;  // flipflop
Sum_2_W64  sum(.amount_0(amount_0),.enable_0(enable_0),.amount_1(amount_1),.enable_1(enable_1),.initialValue((count)),.minValue((minValue)),.maxValue((maxValue)),.overflowed(overflowed_0),.underflowed(underflowed_0),.equalsMax(equalsMax_0),.equalsMin(equalsMin_0),.sum(sum_0));
always_ff @(posedge clk) if(reset) count <= initialValue; else count <= sum_0;  // flipflop_0
assign equalsMin = count == minValue;  // equals
assign equalsMax = count == maxValue;  // equals_0
always_ff @(posedge clk) if(reset) underflowed <= 1'h0; else underflowed <= underflowed_0;  // flipflop_1
endmodule : Counter_L2_

////////////////////

module Day01p2 (
input logic clk,
input logic reset,
input logic turnValid,
input logic [64:0] turn,
output logic turnReady,
output logic [3:0] zeroCount
);
logic ProcessingState_busy;
logic ProcessingState_ready;
logic _in0;
logic [63:0] _in0__s;
logic _in3__s;
logic [64:0] _original__q;
logic [63:0] amount_1;
logic [63:0] count;
logic currentState;
logic enable;
logic equalsMax;
logic equalsMax_0;
logic equalsMin;
logic equalsMin_0;
logic nextState;
logic overflowed;
logic overflowed_0;
logic turnAccepted;
logic turnIsBig;
logic underflowed;
logic underflowed_0;
assign ProcessingState_ready = 1'h0;
assign ProcessingState_busy = 1'h1;
assign _in3__s = turn[0];  // bussubset
assign _in0__s = turn[64:1];  // bussubset_0
//  combinational
always_comb begin
  unique case (currentState) 
      ProcessingState_ready : begin
          turnReady = 1'h1;
          _in0 = _in3__s;
          amount_1 = _in0__s;
          enable = turnValid;
          unique case (1'h1) 
              (turnAccepted & turnIsBig) : begin
                  nextState = 1'h1;
              end
              default : begin
                  nextState = 1'h0;
              end
          endcase

      end
      ProcessingState_busy : begin
          turnReady = 1'h0;
          enable = 1'h1;
          _in0 = (_original__q[0]);
          amount_1 = (_original__q[64:1]);
          unique case (1'h1) 
              (~turnIsBig) : begin
                  nextState = 1'h0;
              end
              default : begin
                  nextState = 1'h1;
              end
          endcase

      end
      default : begin
          nextState = currentState;
          turnReady = 1'h0;
          _in0 = 1'h0;
          amount_1 = 64'h0;
          enable = 1'h0;
      end
  endcase

end

//  sequential
always_ff @(posedge clk) begin
  if(reset) begin
      currentState <= 1'h0;
  end   else begin
      currentState <= nextState;
  end 

end

assign turnAccepted = turnValid & turnReady;  // and__0
assign turnIsBig = _in0__s >= 64'h64;  // greaterThanOrEqual
always_ff @(posedge clk) if(reset) _original__q <= 65'h0; else _original__q <= ({
(amount_1 - 64'h64), /* 64:1 */
_in0  /*    0 */
});  // flipflop
Counter_L2_  dialPositionCounter(.amount_0(amount_1),.enable_0((enable & (_in0 == 1'h0))),.amount_1(amount_1),.enable_1((enable & (_in0 == 1'h1))),.clk(clk),.reset(reset),.overflowed(overflowed),.underflowed(underflowed),.equalsMax(equalsMax),.equalsMin(equalsMin),.count(count));
Counter_L1_  zeroCounter(.enable_0((underflowed | overflowed)),.clk(clk),.reset(reset),.overflowed(overflowed_0),.underflowed(underflowed_0),.equalsMax(equalsMax_0),.equalsMin(equalsMin_0),.count(zeroCount));
endmodule : Day01p2